#!/usr/bin/env node
import { Command } from 'commander';
import chalk from 'chalk';
import spawn from 'cross-spawn';
import { existsSync, mkdirSync, readFileSync, writeFileSync, createWriteStream } from 'node:fs';
import { resolve, dirname, basename } from 'node:path';
import Handlebars from 'handlebars';
import { fileURLToPath } from 'node:url';
import { r as readJsonFile, A as AddonManifest } from './addonManifest-45b9450a.js';
import inquirer from 'inquirer';
import isValidFilename from 'valid-filename';
import archiver from 'archiver';

const installDependencies = (cwd) => {
    spawn.sync('npm', ['install'], {
        stdio: 'inherit',
        cwd,
    });
};

const runLinters = (cwd) => {
    spawn.sync('npm', ['run', 'lint'], {
        stdio: 'inherit',
        cwd,
    });
};

const createFolder = (parentFolder, folderName) => {
    const path = resolve(parentFolder, folderName);
    if (!existsSync(path)) {
        mkdirSync(path);
    }
    return path;
};

const createFileFromTemplate = (templateFilePath, destinationFilePath, templateParams) => {
    const templateFile = readFileSync(templateFilePath, 'utf-8');
    const template = Handlebars.compile(templateFile);
    const file = template(templateParams);
    mkdirSync(dirname(destinationFilePath), { recursive: true });
    writeFileSync(destinationFilePath, file);
};

/**
 * Return the path to currently executing binary (in node_modules)
 * @note This function is going to return an incorrect path if
 * a build does not bundle all files into a single javascript file!
 */
const getBinaryPath = () => {
    const filepath = fileURLToPath(import.meta.url);
    const binaryPath = dirname(filepath);
    return binaryPath;
};

const getPackageJson = () => {
    const binaryPath = getBinaryPath();
    const packageJsonPath = resolve(binaryPath, '../package.json');
    const packageJson = readJsonFile(packageJsonPath);
    return packageJson;
};

const copyTemplate = ({ addonId, addonRootFolderPath, author, extensionDescription, extensionName, extensionRootFolderPath, sitesUrl, }) => {
    const binaryPath = getBinaryPath();
    const templatePath = resolve(binaryPath, 'addon/template');
    const packageJson = getPackageJson();
    createFileFromTemplate(resolve(templatePath, 'addonId.config.json.hbs'), resolve(addonRootFolderPath, `${addonId}.config.json`), {
        extensionName,
    });
    [
        '.browserslistrc',
        '.editorconfig',
        '.eslintrc.json',
        '.gitignore',
        '.prettierrc',
        'babel.config.js',
        'devServer.js',
        'tsconfig.json',
        'src/globals.ts',
        'src/index.tsx',
    ].forEach(fileName => {
        createFileFromTemplate(resolve(templatePath, `extension/${fileName}.hbs`), resolve(extensionRootFolderPath, fileName));
    });
    createFileFromTemplate(resolve(templatePath, 'extension/package.json.hbs'), resolve(extensionRootFolderPath, 'package.json'), {
        extensionName,
        extensionDescription,
        author,
        addonId,
        sitesUrl,
        extensionsApiVersion: packageJson.dependencies['@tridion-sites/extensions'],
        modelsVersion: packageJson.dependencies['@tridion-sites/models'],
        openApiClientVersion: packageJson.dependencies['@tridion-sites/open-api-client'],
        extensionsCliVersion: packageJson.version,
    });
    createFileFromTemplate(resolve(templatePath, 'extension/webpack.dev.config.js.hbs'), resolve(extensionRootFolderPath, 'webpack.dev.config.js'), {
        extensionName,
    });
    createFileFromTemplate(resolve(templatePath, 'extension/webpack.prod.config.js.hbs'), resolve(extensionRootFolderPath, 'webpack.prod.config.js'), {
        extensionName,
    });
};

const createAddonPrompt = async () => {
    return inquirer.prompt([
        {
            type: 'input',
            name: 'addonId',
            message: 'Provide id of the addon:',
            default: 'my-addon',
            validate: (input) => {
                if (/\s+/g.test(input)) {
                    return "Addon id can't have whitespace";
                }
                if (!isValidFilename(input)) {
                    return "Addon id can't have reserved symbols";
                }
                return true;
            },
        },
        {
            type: 'input',
            name: 'addonName',
            message: 'Provide name of the addon:',
            default: 'My addon',
        },
        {
            type: 'input',
            name: 'addonDescription',
            message: 'Provide description of the addon:',
            default: 'My addon for Tridion Experience Space',
        },
        {
            type: 'input',
            name: 'author',
            message: `Provide author's name:`,
            default: 'RWS',
        },
        {
            type: 'input',
            name: 'extensionName',
            message: 'Provide the name of the frontend extension:',
            default: 'my-extension',
            validate: (input) => {
                if (!/^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/.test(input)) {
                    return 'Extension name should adhere to package.json name requirements!';
                }
                return true;
            },
        },
        {
            type: 'input',
            name: 'extensionDescription',
            message: 'Provide description of the extension:',
            default: 'My first extension',
        },
        {
            type: 'input',
            name: 'url',
            message: `Provide the url to Tridion Sites:`,
            validate: (input) => {
                if (!/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}(\.[a-zA-Z0-9()]{1,6})?\b([-a-zA-Z0-9()@:%_\+.~#?&\/=]*)/gm.test(input)) {
                    return `Make sure it's a valid URL`;
                }
                return true;
            },
        },
    ]);
};

const createAddonRootFolder = ({ path, addonDescription, addonId, addonName, author, extensionName, }) => {
    const addonFolderPath = createFolder(path, addonId);
    const manifest = new AddonManifest({
        version: '1.0.0',
        id: addonId,
        name: addonName,
        description: addonDescription,
        author: author,
    });
    manifest.addFrontendExtension(extensionName, [`dist\\${extensionName}\\main.js`], `dist\\${extensionName}\\main.js`);
    manifest.writeFile(addonFolderPath);
    return addonFolderPath;
};

const createAddon = async (path) => {
    const answers = await createAddonPrompt();
    const addonRootFolderPath = createAddonRootFolder({
        path,
        addonId: answers.addonId,
        addonName: answers.addonName,
        addonDescription: answers.addonDescription,
        author: answers.author,
        extensionName: answers.extensionName,
    });
    const extensionRootFolderPath = createFolder(addonRootFolderPath, answers.extensionName);
    copyTemplate({
        addonRootFolderPath,
        extensionRootFolderPath,
        addonId: answers.addonId,
        author: answers.author,
        extensionDescription: answers.extensionDescription,
        extensionName: answers.extensionName,
        sitesUrl: answers.url,
    });
    return {
        addonFolderPath: addonRootFolderPath,
        extensionFolderPath: extensionRootFolderPath,
    };
};

const configureHandlebars = () => {
    Handlebars.registerHelper('camelCase', (text) => {
        return text.replace(/^./gm, match => match.toLowerCase());
    });
    Handlebars.registerHelper('kebabCase', (text) => {
        return text.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
    });
};

configureHandlebars();
const createCommand = async () => {
    const currentProcessPath = process.cwd();
    console.info(chalk.green(`Creating a new addon at: ${currentProcessPath}`));
    const { extensionFolderPath } = await createAddon(currentProcessPath);
    console.info(chalk.green(`Installing dependencies`));
    installDependencies(extensionFolderPath);
    console.info(chalk.green(`Running linters`));
    runLinters(extensionFolderPath);
    console.info(chalk.green('🎉️️ All done! Happy hacking!'));
    console.info(chalk.green(`Your extension is available at: ${extensionFolderPath}`));
};

const packCommand = ({ inputFilesPath, manifestPath, outputPath }) => {
    console.info(chalk.green(`Creating an addon package from folder: ${inputFilesPath}`));
    console.info(chalk.green(`Manifest file path: ${manifestPath}`));
    const manifest = AddonManifest.fromFile(manifestPath);
    const packageName = `${manifest.id}-${manifest.version}.zip`;
    const archive = archiver('zip');
    const zipPath = resolve(outputPath, packageName);
    const stream = createWriteStream(zipPath);
    stream.on('close', () => {
        console.info(chalk.green(`Addon package "${packageName}" has been created at: ${zipPath}.`));
        console.info(chalk.green('It can be uploaded into Addon Manager now.'));
    });
    archive.on('error', error => {
        console.warn('We were unable to create a package.');
        throw error;
    });
    archive.pipe(stream);
    archive.file(manifestPath, { name: basename(manifestPath) });
    archive.directory(inputFilesPath, basename(resolve(inputFilesPath)));
    archive.finalize();
};

const packageJson = getPackageJson();
const program = new Command();
const programName = Object.keys(packageJson.bin)[0];
program
    .name(programName)
    .description('Provides helpers to build, run and deploy addons for Tridion Experience Space')
    .version(packageJson.version);
program
    .command('create')
    .description('Create new Tridion Experience Space addon')
    .usage(`${programName} create`)
    .action(createCommand);
program
    .command('pack')
    .description('Creates a package ready to be used in Addon Manager')
    .usage(`${programName} pack`)
    .requiredOption('-i, --input <string>', 'path to the directory with addon files')
    .requiredOption('-m, --manifest <string>', 'path to the addon manifest file')
    .requiredOption('-o, --output <string>', 'path where to output the package')
    .action(args => {
    packCommand({
        inputFilesPath: args.input,
        manifestPath: args.manifest,
        outputPath: args.output,
    });
});
program.parse(process.argv);
